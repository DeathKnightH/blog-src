# I/O模型
I/O是操作系统的概念，一个完整的 I/O 操作大致可以划分为两步：
* 等待数据
* 从内核缓冲区复制到应用缓冲区

模型通常指 UNIX 的 5 种 I/O模型。

|操作系统级|程序级|
|---|---|
|同步|阻塞 I/O|
||非阻塞 I/O (轮询)|
||I/O 复用|
||信号驱动 I/O|
|异步 I/O||

## 1. 同步 I/O
同步 I/O 指两个步骤中至少有一步当前进程是阻塞的，具体到模型中，所有同步 I/O 模型的第二个步骤（即复制数据）都是阻塞的。
### 1.1 阻塞 I/O
传统的阻塞 I/O 在两个步骤中都是阻塞的，示意图如下：

表现在网络 I/O 上即 1 个 ServerSocket 只能对接一个 client。

虽然有使用多线程创建多个 ServerSocket 的方法来实现伪异步的效果，但是一个服务器能开启的线程数量是有限的，而且大量地创建线程会消耗一定的系统资源，能同时处理的并发请求数量也有限，
通常这种模式的 I/O 最多只能单机处理 1000 以下 TPS，更高的访问量就会产生明显的业务阻塞。

### 1.2 轮询非阻塞 I/O
在传统阻塞 I/O 的等待过程中，应用进程会一直阻塞直到数据准备完毕。

解决这个阶段阻塞的一个解决方案是使用轮询，在等待数据阶段，应用进程不阻塞，但是会定期向内核发送读的系统请求，数据未准备完成会返回错误，此时应用进程可以执行其他操作，直到系统请求返回成功，结束轮询，进行第二步。

### 1.3 I/O 多路复用
非阻塞 I/O 虽然解决了等待数据阶段的阻塞问题，但是仍然是一个进程处理一个 I/O 请求，能处理的并发请求数量相较于阻塞 I/O 并没有提升。

多路复用 I/O 在单个线程中同时监控多个 socket，通过 select/poll/epoll 查看所负责的 socket，当某个 socket 有数据到达，就通知用户进程。所以也被称为 **事件驱动 I/O**。

之所以叫多路复用，就是因为阻塞的工作线程不会占用 CPU 资源，而选择器可以在众多阻塞的工作线程中选择一个来使用 cpu 资源，这些线程在同一时间只有一个在使用 cpu 资源。

### 1.4 信号驱动 I/O

## 2. 异步 I/O
AIO（Asynchronous I/O）在 JDK 中又被称为 NIO2，在 Java 7 中引入。

与同步 I/O 最大的区别就是两个 I/O 步骤都是非阻塞的。
