# JVM 垃圾回收
## 1. 如何判断一个对象是否可回收
### 1.1 引用计数法
因为难解决循环引用的问题，JVM 不使用此方法。

### 1.2 可达性分析法
以 GCRoots 为起点，分析起点到引用对象的引用链，如果不可达就可以回收。

GCRoots 一般包含以下内容：
* 虚拟机栈中引用的对象
* 本地方法栈中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象

### 1.3 方法区回收
参考 [JVM 内存结构——方法区部分](./JVM内存结构.md#53-方法区的垃圾回收)。

使用 `-Xnoclassgc` 参数可以关闭类卸载功能。

## 2. 引用类型与垃圾回收
Java 中有 4 中类型的引用，引用的类型和对象回收的时机息息相关。

### 2.1 强引用
强引用的对象只有在 GCRoots 不可达的情况下才会被回收。

平时直接用 new 语句创建的对象都是强引用对象，例如：
```
Object obj = new Object();
```

### 2.2 软引用
即使 GCRoots 可达，软引用对象也会在内存不足时被回收。

Java 中用 SoftReference 类创建和管理软引用，例如：
```
SoftReference<String> softString = new SoftReference<String>(new String("test"));
```

在 JVM 内存不足时，GC 会回收软引用，回收后以上代码的 `softString.get()` 会返回 `null`。

### 2.3 弱引用
比软引用更弱，只要发生 GC，不论内存是否不足，弱引用都会被回收。

Java 中用 WeakReference 类创建和管理弱引用，例如：
```
WeakReference<String> softString = new WeakReference<String>(new String("test"));
```

只要发生 GC，回收后以上代码的 `softString.get()` 会返回 `null`。

### 2.4 虚引用
需要和 ReferenceQueue 一起使用，用来跟踪对象被垃圾回收的活动。

虚引用无法获得对象，也不会对对象本身的生命周期产生影响，只是记录该对象将要被回收的标记，例如：
```
ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();
String test = new String("test");
PhantomReference<String> softString = new PhantomReference<String>(test, referenceQueue);
```

当 `test` 对象被标记即将回收时，会被放入 `referenceQueue`。

## 3. 垃圾收集算法
不讨论具体实现，只讨论原理和问题。
### 3.1.标记-清除
这种算法是最基础的垃圾回收算法，后续大多都是在此基础上改进的。

#### 3.1.1 原理
大概分为两步：
* 先标出所有要回收的对象。
* 然后统一回收所有被标记的对象。

#### 3.1.2 问题
此算法主要存在两个问题：
* 效率问题：标记和清除两个过程效率都不高
* 空间问题：清除后可能产生大量内存碎片，导致后续内存余量足但需要大的连续空间时可能因为内存不够而导致各种问题（提前扩容/提前GC等）

### 3.2 标记-整理
#### 3.2.1 原理
也是分为两个步骤：
* 和标记-清除一样先标出所有要回收的对象。
* 然后将未标记的对象都向一端移动，直接清理端边界外的内存。

#### 3.2.2 问题
还是效率问题，如果大量对象死亡，那么标记和整理都会耗费较长时间。

### 3.3 复制
针对每次 GC 大量对象死亡，小部分对象存活的情况，也有这种复制算法。

#### 3.3.1 原理
将要 GC 的内存分为两块，每次只使用一块内存，在 GC 时把存活对象复制到另一块中，然后直接清理发生 GC 的这一块内存。

#### 3.3.2 问题
大部分对象存活时需要复制大量对象，效率较低。

### 3.4 分代收集
因为以上的种种问题，没有一种垃圾收集算法能完美解决所有情况，现代商用 JVM 均采用了分代收集的策略。

#### 3.4.1 原理
分代收集不是一种具体的算法，而是根据对象存活周期将内存分代，对不同的块采用不同的收集算法。

常见的是分为新生代和老年代：
* 新生代用复制算法。
* 老年代用标记整理或者标记清除算法。

## 4. HotSpot 中的垃圾收集器
JDK 8 版本的 HotSpot jvm 有 7 中 垃圾收集器，按照特性可以分为 3 类：
* Serial 单线程串行
* Parallel 多线程并行，是 Serial 的多线程版
* Mostly Concurrent 绝大多数工作时间是并发的，对工作线程暂停影响很小

### 4.1 Serial
#### 4.1.1 Serial 收集器
|启用参数|特点|使用范围|
|---|---|---|
|-XX:+UseSerialGC|单线程，使用复制算法|新生代|

client 模式下默认的新生代收集器。

只能和 CMS、Serial Old 配合使用。

#### 4.1.2 Serial Old 收集器
|启用参数|特点|使用范围|
|---|---|---|
|-XX:+UseSerialOldGC|单线程，使用标记-整理算法|老年代|

### 4.2 Parallel
#### 4.2.1 ParNew 收集器
|启用参数|特点|使用范围|
|---|---|---|
|-XX:+UseParNewGC|多线程，使用复制算法|新生代|

#### 4.2.2 Parallel Scavenge 收集器
|启用参数|特点|使用范围|
|---|---|---|
|-XX:+UseParallelGC|多线程，使用复制算法|新生代|

server 模式下默认的新生代收集器。
