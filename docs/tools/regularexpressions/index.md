# 字符串处理-正则表达式
Regular Expression （正则表达式）是由字符和元字符组成的一种有特定规则的特殊字符串，该字符串定义了一个特殊的模式，被用于字符串查找、匹配。

## 1. 语法
### 1.1 常用元字符
|元字符|含义|
|---|---|
|^ |开始|
|$ |结束|
|\\ |转义紧跟在后面的字符|
|{n}|n为非负整数，前一个子表达式匹配确定的 n 次|
|{n,}|n为非负整数，前一个子表达式匹配至少 n 次|
|{n,m}|n、m 均为非负整数且 n <= m，前一个子表达式匹配至少 n 次，最多 m 次|
|+ |前一个子表达式匹配至少 1 次，相当于 `{1,}`|
|* |前一个子表达式匹配至少 0 次，相当于 `{0,}`|
|?|前一个子表达式匹配至少 0 次，至多 1 次，相当于 `{0,1}`|
|\| |表示或，前后子表达式匹配其中一种|

### 1.2 java 中使用 regex
使用 JDK 原生的 `java.util.regex.Matcher` 类和 `java.util.regex.Pattern` 类，JDK 8 中仍采用 NFA 引擎。

```
Pattern pattern = Pattern.complie("正则表达式");
Matcher matcher = pattern.matcher("待搜索的内容");
matcher.matches(); // 有匹配内容返回 true，没有则返回 false
matcher.find(); // 返回是否找到下一个匹配内容，通常和group(int)一起使用
matcher.group(int); // 根据 index 返回匹配的组，0 处是整个输入字符串，从 1 开始是从左往右依次排列的所有匹配的子字符串
```

## 2. 正则表达式引擎
### 2.1 NFA
The Nondeterministic Finite Automaton （非确定性有穷自动机），特点是包含了回溯的过程，可能对输入字符串中的每个字符进行多次重复计算，最坏情况时间复杂度可能是指数级的。

传统的 NFA 在匹配到一个串后直接返回结果。

### 2.2 DFA
The Deterministic Finite Automaton（确定性有穷自动机），不会回溯，不支持捕获括号，特点是会花较长的时间对表达式进行预处理，搜索时只扫描目标字符串一次。

DFA 会返回目标串中最长的匹配串。

### 2.3 POSIX NFA
原理类似 NFA，但是在匹配过程中会记录匹配到的字符串，最后返回最长的匹配字符串，与传统的 NFA 的区别是当匹配到一个字符串时还会继续尝试搜索更长的匹配串。

### 2.4 Hybrid NFA/DFA
## 3. 常用正则表达式
* IPV4 地址：

> ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
* 邮箱：

> ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
* 国内手机号：

> ^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
* 国内身份证号：

> ^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$
