# 数据库设计
## 1. 设计理论
### 1.1 名词解释
- Table（表）：数据库的数据的一个集合，由多个列和行组成，同一张表的数据共用同样的列。
- Attribute（属性）：表的列名。
- Tuple（元组）：表的一行数据。
- Domain（域）：属性的数据类型。
- Relation（依赖）：属性之间存在的某种联系。
- Schema（模式）：逻辑结构，属性在逻辑上组成的集合。
- Key（键）：由一个或多个属性组成的一个整体，通常是有唯一性的（即当两个元组的键相同，则其所有属性都相同）。一个属性可以存在于不同的键中，一张表也可以有多个键。
- Primary key（主键）：唯一性标识，不可为空，一个表中只能有一个主键。
- Candidate key（候选键）：由一个或多个属性组成的一个整体，具有主键的特征，都有资格成为主键。
- Super key（超键）：键的超集，包含键的属性集合。
- Foreign key（外键）：在关系 A 中的一个或多个属性在关系 B 中是一个 key，那么该属性集合在 A 中被称为外键。
- Prime attribute（主属性）：所有候选键里包含的属性都是主属性。
- Projection（投影）：
- Selection（选择）：按一定条件选择元组。
- Cross join（交叉连接）：又称笛卡尔积，将关系 A 和关系 B 中的每一行进行组合，保留所有组合结果。
- Natural join（自然连接）：将关系 A 和关系 B 中的每一行进行匹配，只保留相同的部分，去掉不匹配的部分。
- Theta join（θ连接）：又称连接，带约束条件的笛卡尔积。即在两个关系的笛卡尔积中根据条件过滤获取符合条件元组集合。
- Outer join（外连接）：自然连接时将不匹配的部分属性置为 null，并加入结果集。
- Division（除法运算）：关系 A 除以关系 B 得到结果 T，T 的属性是所有在 A 中但不在 B 中的属性集合，T 的元组包含了 A 所有元组和 B 所有的元组的一一组合。
### 1.2 函数依赖
在一个关系 R 中，属性组 A 的值由属性组 B 决定，即唯一确定的 B 能确定唯一的 A 值。

* 完全函数依赖：必须由完整的一组 B 属性才能决定 A
* 部分函数依赖：B 中的部分属性也可以决定 A
### 1.3 异常和范式
#### 1.3.1 异常
不符合范式会造成异常。
以一张学生选课表为例：
学号, 姓名, 年龄, 课程名称, 成绩, 学分
* 数据冗余：同一个学生选修了 n 门课，则 (学号，姓名，年龄)在表中重复了 n 次。
* 修改异常：如果修改一门课的学分，那么要同时修改选了这门课的所有学生对应的元组的学分，否则或造成修改异常。
* 删除异常：如果删除一门课，那么要同时删除选了这门课所有学生对应的元组，否则会造成删除异常。
* 插入异常：插入一个元组，如果课程不存在，则会造成插入异常。

#### 1.3.2 1NF 第一范式
定义：属性不可分。
理解：一列只能表示单一的属性，不能把多种属性合并到一列。
实现方式：不用特地去实现，现代关系型数据库的表天然就是符合第一范式的，每个属性(列)只能使用一种类型。

#### 1.3.3 2NF 第二范式
定义：在满足 1NF 的前提下，每个非主属性都完全依赖于键码。
理解：
实现方式：

#### 1.3.4 3NF 第三范式
定义：在满足 2NF 的前提下，每个非主属性都不传递依赖于键码。
理解：
实现方式：

## 2. 设计流程
