# 其他优化手段
## 1. 数据库设计相关
### 1.1 选择合适的数据类型
* 多用算术运算，少用字符串运算。
* 选取尽量小的类型。
* 尽量使用 `NOT NULL` 声明列。
* 如果字符串列差异个数少，尽量考虑使用 `ENUM`。
* 定期使用 `OPTIMIZE TABLE` 清理 InnoDB 和 MyISAM 引擎的表碎片。
* 可以将大量相关数据/结果过于复杂的数据压缩存储到 `BLOB` 或 `TEXT` 类型的列中，可以用单个检索查出所有数据。
* 可以将表中的 `BLOB`/`TEXT` 列单独剥离出来作为一个单独的附表，可以提升主表其他数据的查询效率，也可以有效减小主表的表碎片和处理碎片的效率。
* 合理使用"合成索引"，比如使用表中几个强相关的列计算得到一个散列值列，作为索引列。

### 1.2 选择合适的表存储类型
#### 1.2.1 列长度
* MyISAM
  * CHAR：固定长度，空间占用高，处理速度快，不会产生大量表碎片，崩溃时易于重建。
  * VARCHAR： 不定长度，平均空间占用低，处理速度慢，会产生大量表碎片，崩溃时重建慢。
* InnoDB
  * 变长和固定长度的列没有性能差距，只有存储空间区别。`VARCHAR` 平均占用空间小，在列中存在大量 `null` 值时优势更明显，因为 `CHAR` 类型的 `NULL` 也会占用和其他非 null 值一样大的空间。

#### 1.2.2 行格式
在 InnoDB 中行格式也会影响查询效率，指定行格式：
```
CREATE TABLE table_name (define) ENGINE=InnoDB ROW_FORMAT=COMPRESSED;
```

修改行格式：
```
ALTER TABLE table_name ROW_FORMAT=COMPRESSED;
```

  * `COMPACT`：默认格式，适合绝大多数情景。
  * `COMPRESSED`：压缩格式，适合包含大量重复数据的表，占用空间小，读取数据快，会有额外的压缩/解压消耗（但远低于节省的读取时间）。
  * `DYNAMIC`：动态格式，适合表内有超长的 `TEXT`/`BLOB` 数据。

*ps:`COMPRESSED` 和 `DYNAMIC` 都需要 Barracuda 文件格式的支持，需要设置系统变量 `innodb_file_per_table` 和 `innodb_file_format`*

### 1.3 

## 2. 应用相关
### 2.1 优化数据访问
#### 2.1.1 减少请求数据量
* 限制返回的列数：尽量不使用 `SELECT *` 语句，只返回必要的列。
* 限制返回的行数：在非必要时不要返回大量行的结果集，使用 `LIMIT` 子句限制每次查询返回的行数量。
* 缓存重复查询：把经常需要重复查询的数据放在缓存中，请求不进入数据库，减少重复查询的请求次数，能大幅提升性能。

#### 2.1.2 
