# 索引-MySQL

索引是最常见和常用的优化查询技术，对于中/大型表，索引的优化效果十分明显，这也是通常业务数据库中最常见的表规模。

对于小型表，全表扫描可能效率更高。

对于特大型表，使用分区/分表技术更合适。



## 1. 按数据结构分类

### 1.1 HashTable

`MEMORY` 引擎默认索引结构。

哈希表精确等值查询时间复杂度很低，到达了 O(1)，但是有如下缺点：

* 无法用于排序与分组。
* 只支持精确查找，无法用于部分查找和范围查找。

实现原理很简单，就是针对索引字段计算哈希值，后续精确查找时计算条件的哈希值直接到对应位置取值。

现在单独使用 HashTable 索引很少，最常见的是使用 B+ Tree 索引时的 `自适应哈希索引`，对 B+ Tree 索引中频繁使用的索引值计算哈希，建立针对索引值的哈希索引，增强 B+ Tree 索引在精确查找时的性能。



### 1.2 B+ Tree

`InnoDB` 和 `MyISAM` 引擎默认的索引结构。

B+ Tree 由二叉树一路演进而来：

* 二叉树要查找快速，于是有了二叉查找树。

* 二叉查找树在最坏情况下会退化成链表，于是有了平衡二叉查找树，最有名的实现方案就是红黑树。
* 红黑树出度为 `2`，在数据量打的时候高度还是太高了，检索次数太多。于是有了多叉平衡查找树 B-Tree。
* 由于磁盘 I/O 的特性，每次会顺序读取相邻的一整段数据，于是又有了 B+ Tree，在多叉平衡查找树的基础上把叶子结点链接成链表，提高区间查找性能。



#### 1.2.1 数据结构

所有叶子结点都在同一层，叶子节点连成一个链表，同时兼具平衡查找树和顺序访问的特性。

如图，一个节点的 key 从左到右非递减排列：

![img](https://pdai.tech/_images/mysql/061c88c1-572f-424f-b580-9cbce903a3fe.png)



#### 1.2.2 引擎实现区别

MyISAM 和 InnoDB 引擎索引结构都是 B+ Tree，但是实现时有区别：

|                    | MyISAM                                                       | InnoDB                                                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 索引文件和数据文件 | 分开。先查找索引，找到目标数据后还需要根据地址去数据文件中获取数据。 | 统一。主索引文件本身就是数据文件即`.ibd` 文件，查找到目标索引值后可以直接取到数据。 |
| 实现分类           | 又称`非聚簇索引`。                                           | 又称`聚簇索引`。                                             |
| 辅助索引           | 没有分类，都是普通索引。                                     | 需要根据辅助索引找到主索引值，在查找主索引文件。             |



## 2. 按索引类型分

### 2.1 主键索引（Primary Key）

一张表只能有 `1` 个主键，因此也只能有 `1` 个主键索引。

主键字段值不能为 `NULL` 且不能重复，在 InnoDB 中如果建表时没有显示指定表的主键时，会先检查表中是否有建立了`唯一索引`的字段：

* 有，则选择该字段作为默认主键
* 没有，则自动创建一个 `6` byte 大小的字段作为自增主键



### 2.2 二级索引（辅助索引）

二级索引的叶子节点存储的数据为 `主键值`。通常也是用二级索引定位主键值，再返回主键索引定位数据值。

以下索引均属于二级索引：

* 非主键的唯一索引。
* 普通索引。
* 前缀索引。



## 3. 按数据存储方式分

### 3.1 聚簇索引

聚簇索引即索引结构和数据存放在一起的索引，InnoDB 的主键索引就属于聚簇索引。

**优点**：

​	使用聚簇索引查询很快，定位到索引值就定位到了数据。

**缺点**：

* 依赖于有序的数据：如果数据本身无序，那么插入时还需要先进行排序。
* 更新代价大：如果索引列数据被修改，索引本身也需要修改，对应的数据也需要修改，这样代价会很大。因此一般建表时主键会设置不可修改。

### 3.2 非聚簇索引

非聚簇索引，顾名思义和聚簇索引相反，索引结构和数据分开存储，二级索引都是非聚簇索引。

由于 MyISAM 引擎的实现特点，存储表数据和索引时分为两个文件，因此 MyISAM 的索引都是非聚簇索引。

**优点**：

​	更新代价小，只用更新索引结构和指向数据的地址就行了。

**缺点**：

* 依赖有序数据
* 有可能会二次查询（即回表）：如果查询的目标没有覆盖索引，那么查找辅助索引后，还需要根据查找到的值到`主键索引`或者`数据文件`中进行二次查找。



## 4. 使用索引

### 4.1 添加索引

- 创建表时添加索引：

  ```sql
  CREATE TABLE text_table (
    id INT NOT NULL,
    col1 INT NOT NULL DEFAULT 1,
    col2 VARCHAR(45) NULL,
    PRIMARY KEY ('id'),
    INDEX index1 ('col1'));
  ```

- 添加 PRIMARY KEY（主键索引）：

  ```sql
  ALTER TABLE 'table_name' ADD PRIMERY KEY('column_name');
  ```

- 添加 UNIQUE （唯一索引）：

  ```sql
  ALTER TABLE 'table_name' ADD UNIQUE('column_name');
  ```

- 添加 INDEX （普通索引）：

  ```sql
  ALTER TABLE 'table_name' ADD INDEX index_name('column_name');
  ```

- 添加 FULLTEXT （全文索引），5.6 之前只有 MyISAM 支持，5.6 之后 InnoDB 支持：

  ```sql
  ALTER TABLE 'table_name' ADD FULLTEXT('column_name');
  ```

- 添加多列索引：

  ```sql
  ALTER TABLE 'table_name' ADD INDEX index_name('column_name1','column_name2','column_name3');
  ```

  

### 4.2 修改/删除索引

MySQL 没有修改索引的命令，只能先删再创建一个同名索引。

```sql
ALTER TABLE table_name DROP INDEX index_name;
CRAETE INDEX index_name ON table_name ('column_name');
```



### 4.3 查看索引

有多个数据库时需要添加数据库限定命，以下两种方式都行：

```sql
SHOW INDEX FROM table_name [FROM db_name];
SHOW INDEX FROM [db_name.]table_name;
```



## 5. 索引优化

### 5.1 选择合适的索引列

* 合适的字段
  * 不为 NULL 的字段。
  * 被频繁查询的字段。
  * 被作为查询条件的字段。
  * 被频繁排序的字段。
  * 被频繁用于连接的字段

* 不合适的字段：
  * 被频繁更新的字段。
  * 选择性弱的字段，比如`性别`，只有两种取值。

***ps:选择性强弱是指不重复的值占记录总数的比例，唯一索引选择性最强。***



### 5.2 覆盖索引

查询结果包含在索引中，比如只查询主键值，而主键值本身就是索引的 key，这样做有以下好处：

* 索引值本身占用空间较小时，可以减少磁盘数据访问量。
* 在 MyISAM 中覆盖索引可以不查询数据文件，减少了系统调用。
* 在 InnoDB 中辅助索引如果覆盖可以不用二次查询（回表）。



### 5.3 独立使用索引字段

在查询语句中不能将索引字段放入表达式/函数中，否则查询不会使用索引。

例如，如果对 student 表的 score 字段添加了普通索引，那么查询这么写就不会使用索引去查询：

```
SELECT score FROM student WHERE score + 1 = 60;
```



### 5.4 多列索引

当需要使用多个列作为条件进行查询时，使用多列索引往往比多个单列索引性能更好。

但是多列索引也要注意避免冗余索引，当(a,b,c)命中时(b) 也一定命中，那么 (b) 就是冗余索引，所以在使用多列索引的情况下，很多单列索引都是冗余索引，也引申出了一个说法是尽可能地使用多列索引。



### 5.5 索引列使用顺序

把选择性强的索引列放在前面。



### 5.6 对于可变长字段使用前缀索引

例如 BLOB、TEXT 和 VARCHAR 类型的列，使用前缀索引，只索引开始的部分字符：

```sql
ALTER TABLE 'table_name' ADD INDEX index_name (column_name(length));
```



### 5.7 定期清理未使用索引

索引是需要占用磁盘空间的，也会对 MySQL 服务器造成额外的性能损耗，可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引长期未使用，可以考虑清除这些索引。