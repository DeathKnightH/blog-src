# 单例模式
## 1. 概念
Singleton 是保证一个类只提供一个实例的创建型设计模式。

## 2. 意图
通过私有化构造函数控制实例构造，只对外提供一个公有静态函数返回该类实例，来保证该类在全局只有一个实例。

这样单例模式同时解决了两个问题：
* 共享资源的访问
* 提供一个类实例的全局访问节点

## 3. 类图示例
![singleton](../../resource/design_pattern/singleton.drawio.png)

如图：
* 构造函数和静态实例变量都是私有的，防止其他对象使用单例类的 new 语句。
* 只有一个公有静态函数返回实例，保证无论是静态代码还是实例代码访问都获取的是同一个单例。

## 4. 适用场景
### 4.1 业务场景
* 大部分时候的多线程共享资源问题都可以通过栈封闭+单例模式解决。
* 如果一个类在逻辑上全局只能有一个实例，就要使用单例，例如全局的配置类。

### 4.2 开源实例
spring 中：
* 所有的 spring bean 默认情况下都是单例模式。

## 5. 实现细节与技巧
单例有很多种具体实现方式，以下做个总结对比：
|实现方式|原理|优点|缺点|
|---|---|---|---|
|Eager initialization|依赖JVM的类加载机制，类加载时同时创建单例，保证只被创建一次|线程安全、初始化速度快、实现方便简单|单例的创建时间不可控，依赖于JVM实现|
|Lazy initialization|代码手动控制创建单例的时机，只有需要用到的时候才构造单例|控制创建时间、节约内存资源|线程不安全|
|Synchronized Lazy initialization|懒加载的改进实现，给构造单例的方法加上 synchronized 关键字修饰|线程安全|因为每次获取对象都要经过锁，同步开销大|
|Lazy initialization with double check locking|懒加载的进一步改进实现，更细粒度地加锁，先不加锁判断 null，如果已创建就直接返回不进入锁代码块|线程安全、同步开销小|代码实现复杂，容易出错|
|Enumeration|利用java 中枚举类型的特殊性，枚举类本身是final的，枚举元素都是静态常量且都通过静态代码块来初始化，构造函数默认就是 private 的|线程安全、实现简单|单例的创建时间不可控，依赖于JVM实现|
|Inner static class|静态内部类由JVM加载，只会加载1遍，保证了单例。另外只有在使用该内部类时才会被加载，因此也可以控制创建单例的时间|线程安全、实现简单、不用额外的同步开销||

实际工作中多使用 Eager initialization 和 Inner static class 实现单例，使用方便，代码简单，也能很好地保证线程安全。

## 6. 优缺点
优点：
* 可以简化共享操作。
* 全局只创建一个实例，节约空间，也节省创建对象的开销。

缺点：
* 违反单一职责原则。单例模式同时解决2个问题：保证一个类只有一个实例，同时为该实例提供一个全局访问节点。
* 单例模式可能隐藏不良设计，比如强耦合等。
* 构建单例可能需要处理额外的线程安全问题，不过这个问题已经有了成熟的解决方案。


## 7. 与其他设计模式的关系
### 7.1 与其他创建型模式的关系
* 抽象工厂的具体工厂、生成器的具体生成器子类、原型模式的注册中心都很适合用单例模式实现。

### 7.2 与其他非创建型模式的关系
