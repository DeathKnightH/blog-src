# 位运算
## 1. 进制
### 1.1 进制的基本概念
#### 1.1.1 进位计数制
  任何一种进位计数制都有一个基数，基数为 `X` 的进位计数制称为 `X` 进制，意味着每个数位上运算时都是逢 `X` 进 `1`。
  
#### 1.1.2 进制间转换
##### 非十进制转十进制
  计算每个数位的加权和即可。
  例如将16进制数 `1A60.5` 转换为十进制：
  > 1A60.5 = 1 * 16^3 + 10 * 16^2 + 6 * 16^1 + 0 * 16^0 + 5 * 16^-1 =  6752.3125

##### 十进制转非十进制
  一般将整数部分和小数部分分开计算。
  * 整数部分
    将整数部分每次除以 `X`，记录每次计算的余数，直到被除数变为0。然后反向遍历余数结果就可以得到 `X` 进制数。
    
    以 `2` 进制为例，将十进制数 `100` 转换为 `2` 进制：
    ```
    100 / 2 = 50 余 0
    50 / 2 = 25 余 0
    25 / 2 = 12 余 1
    12 / 2 = 6 余 0
    6 / 2 = 3 余 0
    3 / 2 = 1 余 1
    1 / 2 = 0 余 1
    ```
    
    得到 `2` 进制表示为 `1100100`。
    
  * 小数部分
    将小数部分每次乘以 `X` 直到变为 0，记录每次结果的整数部分，正序遍历整数结果即可得到 `X` 进制表示的小数。
    
    以 `2` 进制为例，将十进制数 `0.7235` 转换为 `2` 进制：
    ```
    0.375 * 2 = 0.75 整数部分为 0
    0.75 * 2 = 1.5 整数部分为 1
    0.5 * 2 = 1 整数部分为1
    ```
    
    得到 `2` 进制表示为 `0.011`。
    由于乘法的结果最后不一定总能将小数位清 0，所以很多时候一种进制下的有限小数转换为其他进制时会变成无限循环小数。例如十进制的 `0.9` 转换为二进制结果为
    `0.1[1100]` 后四位无限循环。

##### 其他进制间的转换
  一般的思路是转换为十进制再转换到目标进制。
  
  如果要转换的进制间存在对数关系，可以直接转换，比如二进制转换到八进制，因为 `8 = 2^3`，可以每3位一组计算得到对应位数上的值。例如二进制 `110010011` 转换为八进制，先分组：
  > 110|010|011
  
  再分别计算得到对应位数的八进制数字：
  > 6|2|3

### 1.2 java 中的二进制
#### 1.2.1 原码和反码
原码由两部分组成：
* 符号位，最高的一位，`0` 表示正数，`1` 表示负数。
* 数值，其余位置正常表示一个数的真值。

反码则是在表示负数时将除符号位以外的位置取反。

例如：
```
+11 的原码是 0000 0000 0000 0000 0000 0000 0000 1011
    反码也是 0000 0000 0000 0000 0000 0000 0000 1011
-11 的原码是 1000 0000 0000 0000 0000 0000 0000 1011
    反码则是 1111 1111 1111 1111 1111 1111 1111 0100
```

#### 1.2.2 补码
补码中 `0`/正数表示与原码和反码一致，负数是在反码的基础上加1得到的。
例如：
```
-11 的原码是 1000 0000 0000 0000 0000 0000 0000 1011
    反码则是 1111 1111 1111 1111 1111 1111 1111 0100
    补码则是 1111 1111 1111 1111 1111 1111 1111 0101
```

这样做有两个好处：
* 不会有 `+0` 和 `-0`, `0`统一属于正数表示。
* 减法运算可以直接将一个正数和一个负数对应的位数相加即可，不用采用更复杂的逻辑判断。

因此 java 中的整形采用补码进行表示。

#### 1.2.3 无符号整形
java 语言本身不支持无符号整形。

但是 jdk 8 之后添加了很多无符号整形的 API 来执行无符号的一些操作，这些 API 中使用一个正常的 int 表示一个无符号整形，使用诸如 `compareUnsigned`/`divideUnsigned` 之类的 API 进行无符号的计算/比较。

## 2. 位运算
### 2.1 基本位运算
#### 与
运算符：`&`

规则：对每个二进制位，当两个数对应的位均为 1 时，结果为 1，否则为 0.
```
0 & 0 == 0
0 & 1 == 0
1 & 0 == 0
1 & 1 == 1
```

#### 或
运算符：`|`

规则：对每个二进制位，当两个数对应的位均为 0 时，结果为 0，否则为 1.
```
0 | 0 == 0
0 | 1 == 1
1 | 0 == 1
1 | 1 == 0
```

#### 异或
运算符：`^`

规则：对每个二进制位，当两个数相同时，结果为 0，否则为 1.
```
0 ^ 0 == 0
0 ^ 1 == 1
1 ^ 0 == 1
1 ^ 1 == 0
```

#### 取反
运算符：`~`

规则：对每个二进制位进行取反操作，0 变 1,1 变 0.
```
~0 == 1
~1 == 0
```

#### 位移
算术位移：带符号的位移。左移时，高位丢弃，低位补0。右移时，低位丢弃，高位补最高位

java 中对应的运算符是：
```
<< // 算术左移
>> // 算术右移
```

示例：
```
1 << 1 == 2 // 0000 0000 0000 0000 0000 0000 0000 0001 左移1位后为 0000 0000 0000 0000 0000 0000 0000 0010 高位丢弃，低位补0
-1 << 1 == -2 // 1111 1111 1111 1111 1111 1111 1111 1111 左移1位后为 1111 1111 1111 1111 1111 1111 1111 1110 高位丢弃，低位补0
-1 >> 2 == -1 // 1111 1111 1111 1111 1111 1111 1111 1111 算术右移2位后为 1111 1111 1111 1111 1111 1111 1111 1111 低位丢弃，高位补最高位即1
```


逻辑位移：由于逻辑左移和算术左移是一样的，只讨论逻辑右移。不带符号的位移，直接对所有二进制位进行右移，高位补 0。java 中对应的运算符是：
```
>>> // 逻辑右移
```

示例：
```
-1 >>> 1 == 2147483647 // 1111 1111 1111 1111 1111 1111 1111 1110 进行逻辑右移1位后为 0111 1111 1111 1111 1111 1111 1111 1111 低位丢弃，高位补0
```

### 2.2 性质
* 幂等律： 
> a & a = a
> a | a = a

* 交换律：
> a & b = b & a
> a | b = b | a
> a ^ b = b ^ a

* 结合律：
> (a & b)& c = a &(b & c)
> (a | b)| c = a |(b | c)
> (a ^ b)^ c = a ^(b ^ c)

* 分配律：
> (a & b)| c = (a | c)&(b | c)
> (a | b)& c = (a & c)|(b & c)
> (a ^ b)& c = (a & c)^(b & c)

* 德摩根律：
> ~(a & b) = (~a) | (~b)
> ~(a | b) = (~a) & (~b)

* 针对补码的取反
> -a = ~(a - 1)

例如：
```
-1 == ~0
```

### 2.3 位运算常用公式

- 计算只包含最后一位1的二进制数

  x&-x

- 计算消除了最后一位1的二进制数

  x&（x-1）

* 计算最大公约数

    x % y 一直递归下去，直到x＝＝y就是最大公约数。
    
* 查找重复数字

    x^x == 0

    x^x^x == x

    奇数次异或可以得到原数字，偶数次异或得到0，可以用来区分重复次数分别为奇数和偶数的两组数字。

  

## 4. 应用方案

* 二进制压缩

  当问题有一系列不同的元素只有有限种状态时，可以用**一个数**的二进制表示状态，称为二进制压缩。
  
  例如表示10个物体，每个物体有两种状态，拿或者不拿，则可以用一个 10 位的二进制数表示当前选择的状态。

- 二进制归并

  0x55555555

  0x33333333

  0x0f0f0f0f

  0x00ff00ff

  0x0000ffff

  经常用于二进制位上的二路归并，可用于排序（比如二进制位反转），也可用于计数（比如计算二进制位中1的个数）。例如：
  ```
  int n;
  n = (n & 0x55555555) + ((n >>> 1)  & 0x55555555); // 计算每 2 位的 1 的个数和，结果存在原数中，因为每 2 位的 1 的个数不超过 2，所以用 2 个二进制位刚好能存
  n = (n & 0x33333333) + ((n >>> 2)  & 0x33333333); // 基于上一步的结果计算每 4 位的 1 的个数和，结果存在原数中，因为每 4 位的 1 的个数不超过 4，所以用 4 个二进制位肯定能存下
  n = (n & 0x0f0f0f0f) + ((n >>> 4)  & 0x0f0f0f0f); // 基于上一步的结果计算每 8 位的 1 的个数和，结果存在原数中，因为每 8 位的 1 的个数不超过 8，所以用 8 个二进制位肯定能存下
  n = (n & 0x00ff00ff) + ((n >>> 8)  & 0x00ff00ff); // 基于上一步的结果计算每 16 位的 1 的个数和，结果存在原数中，因为每 16 位的 1 的个数不超过 16，所以用 16 个二进制位肯定能存下
  n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff); // 基于上一步的结果计算每 32 位的 1 的个数和，结果存在原数中，因为每 32 位的 1 的个数不超过 32，所以用 32 个二进制位肯定能存下
  return n; //到这里一个 32 位二进制的数中 1 的个数就已经统计完成了
  ```

- hash表和位运算配合可以大幅降低时间复杂度和空间复杂度

比如用二进制压缩后的 mask 作为 key，而符合 mask 状态的条件作为 value 组成一个 hash 表。

- 状态机用位运算可以在有限内存下表示更多状态

## 5. 习题
* [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)
* [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)
* [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)
* [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)
* [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)
