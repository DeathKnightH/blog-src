# 基数排序
基数排序（Radix Sort）是一种**非比较型**排序算法。

最早用于解决卡片排序问题，主要思想是拆分元素，分开排序。

## 1. 工作原理
将待排序的元素拆分为 `k` 个关键字，依次对第 `k` 个、`k-1` 个、`k-2` 个、...`1` 个关键字进行`稳定排序`（任何一种其他的稳定排序算法）。

虽然也要使用其他的稳定排序算法，但是依据拆分关键字的效果，可以显著减少外层排序的循环次数，通常比基于比较的排序算法要快。

## 2.性质
用 `r` 代表关键字基数，`n` 代表序列长度，`c`代表关键字个数。
|性质||描述|
|---|---|---|
|稳定性|稳定|取决于内层排序，内层排序为稳定|
|最坏时间复杂度|O(n(r + c))|基数排序时间复杂度取决于内层排序算法，这里仅供参考|
|最好时间复杂度|O(n(r + c))|基数排序时间复杂度取决于内层排序算法，这里仅供参考|
|平均时间复杂度|O(n(r + c))|基数排序时间复杂度取决于内层排序算法，这里仅供参考|
|空间复杂度|O(c + rn)|额外空间取决于关键字拆分的数量|

## 3. 伪代码
```
Input:一个包含n个可排序元素的序列 A[n]，将每个元素拆分为 k 个关键字。
Output:把输入序列按非递减排序的序列 A[n]。
Method:
for i <- k down to 1
  对第 i 个关键字使用内层排序 
```

## 4. Java 实现，以十进制整数为例
十进制整数的关键字基数为 10，内层可以使用计数排序
```
public static radixSort(int[] source){
  int max = Arrays.stream().max().getAsInt();
  // 按进制划分每次内层排序
  for(int i = 1; max / i > 0; i *= 10){
    countingSort(source, i);  // 内层排序时把每个元素除以 i，做计数排序
  }
}
```
